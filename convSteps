set -e 
trainfile=/iesl/canvas/beroth/tac/data/merge_2013.tab
devfile=/iesl/canvas/beroth/tac/data/candidates2009-2012
goodfile=/home/belanger/relationfactory/stanford/annotated_sentences.tab.nr
goodfile2=/iesl/canvas/beroth/tac/data/gold_candidates
vocabThresh=12

tb=`basename $trainfile`
db=`basename $devfile`
gb=`basename $goodfile`
gb=`basename $goodfile`

flip=0
useTypes=0
outsideWidth=0
min_width=3
out=$PWD/convData_s_types${useTypes}_outside_${outsideWidth}_mw_${min_width}
echo working in $out
mkdir -p $out
ot=$out/$tb
otc=$out/$tb.cross
od=$out/$db
og=$out/$gb
og2=$out/$gb2

seq 1 10000000  > /tmp/seed
echo shuffling
shuf --random-source=/tmp/seed  $trainfile > $ot.shuff.tmp
shuf --random-source=/tmp/seed  $devfile > $od.shuff
shuf --random-source=/tmp/seed  $goodfile > $og.shuff


#crossLen=`wc -l $ot.shuff.tmp | cut -d" " -f1 | xargs -ifoo expr foo / 8`
crossLen=0
tail -n $crossLen $ot.shuff.tmp > $otc.shuff

len=`wc -l $ot.shuff.tmp | cut -d" " -f1`
echo expr $len - $crossLen
trainLen=`expr $len - $crossLen`
head -n $trainLen $ot.shuff.tmp > $ot.shuff

#format: <relname>\t<l/r>\t<string>
#here, l/r=1 if arg1 comes first and 0 if they are swapped
for f in $og $ot $otc $od 
do
	perl sliceArgStringAppend.pl $f.shuff relTypes.txt $flip $useTypes $outsideWidth $min_width > $f.argstring
done


cut -f3 $ot.argstring | tr ' ' '\n' | sort | uniq -c | sort -n -r  | sed 's|^\s*||' | perl -ne '$o = $_; /(\d*)/;  if($1 > 10){print $o;}'> $out/vocab.counts.txt
cut -d" " -f2 $out/vocab.counts.txt > $out/vocab.txt
echo "<unk>" >> $out/vocab.txt

cut -f1 $ot.argstring  | sort -u > $out/labelMap.txt.tmp

if [ "$flip" == 0 ]; then
   cp $out/labelMap.txt.tmp $out/labelMap.txt
   cat $out/labelMap.txt.tmp  | sed 's|$|-reverse|' >> $out/labelMap.txt
else
	cp $out/labelMap.txt.tmp $out/labelMap.txt
fi

for f in $ot $otc $od $og
do
	perl mapToInts.pl $f.argstring  $out/vocab.txt $out/labelMap.txt $flip > $f.argInt
done


mkdir -p $out/trainSplit/
mkdir -p $out/devSplit/
mkdir -p $out/trainCrossSplit/
mkdir -p $out/goodSplit/

perl splitByLength.pl $ot.argInt $ot.shuff $out/trainSplit/train.
perl splitByLength.pl $otc.argInt $otc.shuff $out/trainCrossSplit/trainCross.
perl splitByLength.pl $od.argInt $od.shuff $out/devSplit/dev.
perl splitByLength.pl $og.argInt $og.shuff $out/goodSplit/good.

for f in $out/{train,dev,trainCross,good}Split/*.int.txt
do 
   outfile=`echo $f | sed 's|.txt$|.torch|'`
   len=`basename $f .int.txt| sed 's|.*\.-||'`
   wc -l $f
   echo    th ../NLPConv/seq2torch.lua -file $f -len $len -out $outfile
   th ../NLPConv/seq2torch.lua -file $f -len $len -out $outfile
done



start=$min_width
end=`expr $min_width + 8`

for name in dev trainCross good
do
list=$out/paired.$name.FileList.txt
rm -f $list
for ii in `seq $start $end`
do 
f=$out/${name}Split/$name.-$ii.string.txt
   outfile=`echo $f | sed 's|.txt$|.lhs|'`
   torchfile=`echo $f | sed 's|string.txt$|int.torch|'`   
   cat $f | cut -f1-8 > $outfile
   echo $torchfile $outfile >> $list
done
done
cat $out/devSplit/dev.string.txt.long |  cut -f1-8  > $out/devSplit/dev.string.txt.long.lhs

list=$out/trainFileList.txt
rm -f $list

goodList=$out/goodFileList.txt
rm -f $goodList

for i in `seq $start $end`
do
	echo $out/trainSplit/train.-$i.int.torch >> $list
	echo $out/goodSplit/good.-$i.int.torch >> $goodList
done

