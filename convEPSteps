set -e 

flip=0
mi=1
useTypes=0
outsideWidth=2
min_width=7
vocabThresh=25
padSize=12
out=$PWD/convData_s2_types${useTypes}_outside_${outsideWidth}_mw_${min_width}_mi_$mi_pad_${padSize}
echo working in $out
mkdir -p $out

trainfile=/iesl/canvas/beroth/tac/data/merge_2013.tab
devfile=/iesl/canvas/beroth/tac/data/candidates2009-2012
goodfile=/home/belanger/relationfactory/stanford/annotated_sentences.tab.nr
goodfile2=/iesl/canvas/beroth/tac/data/gold_candidates
testfile=/iesl/canvas/beroth/tac/runs/run20140314/candidates

names=`mktemp`
cat <<_i_ > $names
train:$trainfile
dev:$devfile
stanford:$goodfile
2012Gold:$goodfile2
test:$testfile
_i_

seq 1 10000000   > /tmp/seed2
echo shuffling
for n in `cat $names`
do
	b=`echo $n | cut -d":" -f1`
	f=`echo $n | cut -d":" -f2`

	if [ "$mi" == 0 ]; then
	   shuf --random-source=/tmp/seed2  $f > $out/$b.shuff.tmp 
	   perl filterMaxLength.pl $out/$b.shuff.tmp $maxLen > $out/$b.shuff
	else
	   cat $f | sort -k 1,1  -k 3,3   > $out/$b.shuff.tmp
	   perl filterMaxLength.pl $out/$b.shuff.tmp $maxLen > $out/$b.shuff
	fi

done

rm /tmp/seed2
ot=$out/train


########training set specific stuff##########

#format: <relname>\t<l/r>\t<string>
#here, l/r=1 if arg1 comes first and 0 if they are swapped

perl sliceArgStringAppend.pl $ot.shuff relTypes.txt $flip $useTypes $outsideWidth $min_width > $ot.argstring

cut -f3 $ot.argstring | tr ' ' '\n' | sort | uniq -c | sort -n -r  | sed 's|^\s*||' | perl -ne '$o = $_; /(\d*)/;  if($1 > 10){print $o;}'> $out/vocab.counts.txt
cut -d" " -f2 $out/vocab.counts.txt > $out/vocab.txt
echo "<unk>" >> $out/vocab.txt

cut -f1 $ot.argstring  | sort -u > $out/labelMap.txt.tmp

if [ "$flip" == 0 ]; then
   cp $out/labelMap.txt.tmp $out/labelMap.txt
   cat $out/labelMap.txt.tmp  | sed 's|$|-reverse|' >> $out/labelMap.txt
else
	cp $out/labelMap.txt.tmp $out/labelMap.txt
fi
##############################################

start=$min_width
end=`expr $min_width + 8`

for n in `cat $names`
do
	name=`echo $n | cut -d":" -f1`
	f=$out/$name
	perl sliceArgStringAppend.pl $f.shuff relTypes.txt $flip $useTypes $outsideWidth $min_width > $f.argstring.full
	
	if [ "$mi" == 1 ]; then
	   perl pad.pl $f.argstring.full $padSize  > $f.argstring
        else
	   cp $f.argstring.full $f.argstring
	fi
	
	perl mapToInts.pl $f.argstring  $out/vocab.txt $out/labelMap.txt $flip > $f.argInt

	d=$out/${name}Split/
	mkdir -p $d
	converter=""

        if [ "$mi" == 0 ]; then
	   perl splitByLength.pl $f.argInt $f.shuff $d/$name.
	   converter=../NLPConv/seq2torch.lua
        else
	   cut -f1,3 $f.shuff | sed 's|\t|:::|' > $f.entPairs

	   paste $f.entPairs $f.argInt  > $f.argInt.ep
	   lhs=$d/$name.-0.string.txt
	   cut -f1-8 $f.shuff > $lhs.full
	   perl collectEP.pl $f.argInt.ep $lhs.full $d/$name.-0.int.txt $lhs
	   converter=../NLPConv/miml2torch.lua
	   start=0
	   end=0
	fi
	
	for f in $d/*.int.txt
	do 
	   outfile=`echo $f | sed 's|.txt$|.torch|'`
   	   len=`basename $f .int.txt| sed 's|.*\.-||'`
	   echo th $converter -file $f -len $len -out $outfile
	   th $converter -file $f -len $len -out $outfile
	done
		
	list=$out/paired.$name.FileList.txt
	list2=$out/${name}FileList.txt
	rm -f $list
	rm -f $list2
	for ii in `seq $start $end`	
	do
		f=$out/${name}Split/$name.-$ii.string.txt
		outfile=`echo $f | sed 's|.txt$|.lhs|'`
		torchfile=`echo $f | sed 's|string.txt$|int.torch|'`
		if [ "$mi" == 0 ]; then
		   cat $f | cut -f1-8 > $outfile
		fi
		
		echo $torchfile $outfile >> $list
		echo $torchfile >> $list2
	done
	
done


